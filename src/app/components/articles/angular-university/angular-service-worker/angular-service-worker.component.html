<mat-card >
	<p>Перевод статьи ресурса Angular-University <a target="_blank" href="https://blog.angular-university.io/angular-service-worker">Angular Service Worker - Step-By-Step Guide for turning your Application into a PWA</a>
		<a style="position: absolute; right: 40px; text-decoration: none" routerLink="/">Назад</a>
	</p>
	<div class="imgContainer">
		<img src="/assets/imgs/angular-service-worker/angular-university-logo.png">
	</div>
	<h2 class="articleHeader">Сервисный рабочий Angular - пошаговое руководство превращения приложения в прогрессивное веб приложение (PWA).</h2>
	<p>С поддержкой сервисного рабочего и техники прогрессивных веб приложений, встроенных в интерфейс коммандной строки Angular CLI, теперь проще, чем когда-либо превратить веб приложение в загружаемое и устанавливаемое приложение, подобно настоящим мобильным приложениям. В данной статье мы рассмотрим то, как можно конфигурировать инструмент коммандной строки Angular CLI для генерации приложений, которые после компановки на продакшн получают возможность быть загруженными и  установленными на устройство. Здесь рассмотрим добавление файла манифеста для работы приложения в технике PWA, который и предусматривает настройку файлов для предсказуемого поведения браузера - установки иконки приложения на рабочий стол и предварительную загрузку ресурсов. <br>
	Здесь мы рассмотрим создание первоначальной структуры приложения вновь создаваемого приложения, используя Angular CLI, настройку включения функций для прогрессивных приложений, разберем подробно какую роль играет Angular CLI при добавлении функциональности сервисного рабочего в уже существующее приложение.<br>
	По пути, поговорим о дизайне сервисного рабочего в Angular, и о том, как это работает "под капотом", немного отличаясь от других сборок генерации сервисного рабочего.</p>
	<h3>Лучше чем установка мобильного приложения.</h3>
	<p>В Angular загрузка и установка сервисного рабочего происходит в фоновом (автоматическом) режиме, без необходимости для разработчика иметь опыт работы с сервисными рабочими, и это намного лучше, чем текущий механизм работы мобильных приложений, при котором необходимо загружать постоянные обновления. Механизм прогрессивного приложения имеет неявную поддержку обновлений версий приложения, к примеру, если разработчик меняет в приложении только файл CSS, тогда сервисному рабочему необходимо подгрузить в браузер только эту, обновленную версию файла, не касаясь остальных файлов приложения и не перезагружая приложение полностью.<br>
	Так же, обновление версии приложения может быть обработано в фоне, незаметно для пользователя. Он будет видеть только одну версию приложения в нескольких открытых закладках, а так же существует возможность опроса пользователя для немедленной установки  обновленной версии приложения.</p>
	<h3>Преимущества в производительноси и внесетевая поддержка.</h3>
	<p>Преимущества в производительности от установки всех файлов сборки на браузер пользователя, делает приложение очень быстозагружаемым. Насколько быстро? От нескольких раз до порядков в увеличении производительности загрузки, в зависимости от файлов приложения.<br>
	Любое приложение получает преимущество в производительности, включаемое свойствами PWA загрузки и установки, и не является приоритетом только мобильных приложений. Но получение всех файлов приложение через быстую загрузку и установку в браузер - это только первый шаг осуществления поддержки работы во внесетевом режиме, поскольку он требует не только загрузки и установки. И как мы увидим, преимущества от функций PWA  приложений, которые мы рассмотрим более подробно далее, значительны. </p>
	<h3>Содержание.</h3>
	<p>В статье будут рассматриваться следующие темы:</p>
	<ol class="table-content-block">
		<li class="table-element" *ngFor="let item of tableContent" [innerHTML]="domSanitizer.bypassSecurityTrustHtml(item)"></li>
	</ol>
	<h2>Создание структуры приложения Angular PWA, используя Angular CLI</h2>
	<p>При помощи пары команд, Angular CLI создает нам скелет работающего приложения, способное загружаться и устанавливаться на устройство пользователя. Первый шаг создание PWA приложения - обновить инструмент Angular CLI до последней стабильной версии:  </p>
	<app-sample-code [context]="{header : 'Команда обновления CLI', headerBackground : '#d5dcff', ext : 'cmd'}">
<pre class="dark-blue">
  npm install -g @angular/cli@latest
</pre>
	</app-sample-code>
	<p>Для включения последних функций (бета), возможно использовать такую версию:</p>
	<app-sample-code [context]="{header : 'Команда обновления CLI', headerBackground : '#d5dcff', ext : 'cmd'}">
<pre class="dark-blue">
  npm install -g @angular/cli@next
</pre>
	</app-sample-code>
	<p>После этого запускаем команду генерации оболочки приложения Angular, добавляя в неё поддержку сервисного рабочего:</p>
	<app-sample-code [context]="{header : 'Команда генерации приложения с поддержкой сервисного рабочего', headerBackground : '#d5dcff', ext : 'cmd'}">
<pre class="dark-blue">
  ng new angular-pwa-app --service-worker
</pre>
	</app-sample-code>
	<p>Добавление поддержки сервисного рабочего (PWA) в существующее Angular приложение:</p>
	<app-sample-code [context]="{header : 'Команда генерации добавления PWA в существующее приложение', headerBackground : '#d5dcff', ext : 'cmd'}">
<pre class="dark-blue">
	ng add @angular/pwa --project <span class="dark-red">&#60;имя проекта, как указано в angular.json&#62;</span>
</pre>
	</app-sample-code>
	<h2>Добавление в приложение поддержки Angular PWA вручную.</h2>
	<p>Приложение с поддержкой PWA идентично приложению без поддержки PWA, так что же происходит при включении поддержки, в случае, если нужно включить такую поддержку вручную, не через CLI? Посмотрев в файл <span class="dark-blue">package.json</span>, увидим, что добавился новый модуль <span class="dark-blue">@angular/service-worker</span>, а так же в файле конфигурации <span class="dark-blue">angular.json</span> добавлена настройка <span class="dark-red">"serviceWorker": true</span>.</p>
		<app-sample-code [context]="{header : 'Фрагмент файла angular.json', headerBackground : '#d5dcff', ext : '.json'}">
<pre class="dark-blue">
   <span class="dark-green" >"apps" </span>: [&#123;
      <span class="dark-green" >"root" </span>: <span class="dark-green" >"src"</span>,
      <span class="dark-green" >"outDir"</span>: <span class="dark-green" >"dist"</span>,
      <span class="dark-green" >"assets"</span>: [
        <span class="dark-green" >"assets",
        "favicon.ico"</span>
      ],
      <span class="dark-green" >"index" </span>: <span class="dark-green" >"index.html"</span>,
   ...
      <span class="dark-green" >"serviceWorker" </span>: true
   &#125;]
</pre>
		</app-sample-code>
		<p>Что он определяет? Это флаг помечает приложения для сборки на продакшн и, основываясь на файле конфигурации компоновки <span class="dark-blue">ngsw-config.json</span>, который добавляется CLI в папку <span class="dark-red">src</span> проекта (в этом файле определяются стратегии кэширования, ресурсы, активы и пр.), указывает CLI сформировать два файла (их рассмотрим немного позже) в папке вывода сборки проекта:</p>
	<ul>
		<li>Файл самого сервисного рабочего <span class="dark-blue">ngsw-worker.js</span> </li>
		<li>Вспомогательный файл конфигурации для него во время выполнения <span class="dark-blue">ngsw.json</span>.</li>
	</ul>
	<p>В файле корневого модуля приложения, в область импорта добавляется запись регистрации модуля <span class="dark-blue">ServiceWorkerModule</span>:</p>
	<app-sample-code [context]="{header : 'Регистрация модуля ServiceWorkerModule в модуле проекта', headerBackground : '#d5dcff', ext : '.ts'}">
<pre class="dark-blue">
   @NgModule(&#123;
      declarations: [
         AppComponent
       ],
      imports: [
         BrowserModule,
         AppRoutingModule,
         ServiceWorkerModule.register(<span class="dark-green" >'/ngsw-worker.js'</span>, &#123; enabled: environment.production &#125;)
       ],
      providers: [],
      bootstrap: [AppComponent]
   &#125;)
   export class AppModule &#123;&#125;
</pre>
	</app-sample-code>
	<p>Этот модуль добавляет два полезных сервиса:</p>
	<ul>
		<li><span class="dark-red">SwUpdate</span> - сервис управлением обновлениями приложения. </li>
		<li><span class="dark-red">SwPush</span> - сервис управлением Web Push сообщениями. </li>
	</ul>
	<p>Более того, именно этот модуль регистрирует сервисного рабочего в браузере (при включенной поддержки сервисного рабочего), загружая скрипт <span class="dark-blue">ngsw-worker.js</span>, через вызов  <span class="dark-blue">navigator.serviceWorker.register()</span>. Этот вызов загружает скрипт сервисного рабочего в отдельном HTTP запросе. </p>
	<h3>Файл конфигурации компоновки.</h3>
	<p>Для того, что бы сформировать сам файл сервисного рабочего <span class="dark-blue">ngsw-worker.js</span> и файл загрузки ресурсов и моделей кэширования этих ресурсов <span class="dark-blue">ngsw.json</span> Angular CLI создает файл конфигурации компоновки <span class="dark-blue">ngsw-config.json</span> </p>
	<h2>Механизм кэширования Angular Service Worker.</h2>
	<p>Сервисный рабочий Angular может кэшировать все виды ресурсов в область кэша приложений в браузере <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage">CacheStorage</a>. Эта область кэша не связана со стандартным браузерным кэшем и может управляться приложениями. Цель свойства <span class="dark-blue">assetGroups</span> файла конфигурации компоновки - настройка HTTP запросов, кэширующих ресурсы в кэш приложения, и область настройки кэширования ресурсов:  </p>
	<ul>
		<li><span class="dark-blue">resources</span> - область версионированных ресурсов самого приложения (файлы, необходимые для формирования оболочки приложения, стили, шрифты, картинки и пр.), разделенные на три свойства: files - список шаблонов путей к файлам ресурсов приложения в корневой папке приложения, необходимых для формирования приложения и его страниц.  </li>
		<li><span class="dark-blue">urls</span> - пути или шаблоны путей к ресурсам, получаемых, к примеру из CDN (сторонние библиотеки, шрифты, модули и др.)   </li>
	</ul>
	<p>Свойство <span class="dark-blue">dataGroups</span> -  область указания не версионированных активов - путей к ресурсам API, т.е базам данных. Содержит свойства для адресов и стратегий кэширования подобных ресурсов.</p>
	<p>Свойство <span class="dark-blue">navigationUrls</span> - необязательная область, содержащая настраиваемый список путей перенаправления на индексный файл, т.е. адреса которые нужно перенаправить на индексный файл приложения.</p>
	<h3>Кэширование статических файлов, являющихся оболочкой приложения.</h3>
	<p>Файлы в области <span class="dark-blue">resources</span> - это файлы оболочки приложения, созданные из комбинации индексного файла, CSS, JS сборки. Они необходимы для формирования интерфейса или запроса на сторонний сервер для нужд всего приложения в целом, для всех его страниц и не могут быть загружены по требованию. Эти файлы нужно кэшировать как можно быстрее, с наименьшими затратами по производительности. Файлы из этой области загружаются и устанавливаются сервисным рабочим немедленно, до начала перехвата всех событий <span class="dark-red">fetch</span>. Поэтому в режиме загрузки данных файлов, для имени области <span class="dark-red">app</span> установлено по умолчанию <span class="dark-blue" >installMode : prefetch</span>, т.е. предварительно загружаемый ресурс. Сервисный рабочий не ждет пока эти файлы будут запрошены со страницы, входящую в его контекст обработки, а загружает его сразу, без задержек, кэширует их, что бы после этого немедленно запустить. И при обновлении страницы пользователем в следующий раз, эти файлы будут выдаваться из кэша, а не запрошены с сервера.  </p>
	<h3>Кэширование вспомогательных статических ресурсов.</h3>
	<p>Файлы ресурсов кэшируются, если они были запрошены со страниц, контролируемыми сервисным рабочим - эта модель загрузки называется <span class="dark-blue">lazy</span> (по требованию : <span class="dark-blue"> install mode :  lazy
</span> ) , и если однажды они были загружены, и новая версия этих файлов оказалась доступна на сервере, они будут загружены в режиме предварительной загрузки модели обновления ресурсов (<span class="dark-blue">update mode : prefetch</span> ). Это хорошая стратегия для ресурсов, которые загружаются в отдельном HTTP запросе (к примеру,картинки), они нужны не на каждой странице, открываемой пользователем. Но, если они понадобились, возникает потребность  в их версионированном обновлении так же, поэтому, модель обновления этих ресурсов может так же быть предварительной. Важно понимать, что с настройками по умолчанию в моделях загрузки и обновления ресурсов мы имеем загружаемое и устанавливаемое приложение, готовое к работе.</p>
	<h2>Запуск компоновки приложения для производства.</h2>
	<p>Для начала, добавим немного представления в приложение, чтобы можно было идентифицировать работающую версию приложения в браузере. К примеру, можем заменит содержимое файла <span class="dark-red">app.component.html</span> на заголовок: </p>
	<h2>Запуск PWA приложения на продакшн.</h2>
	<p>Для того, что бы запустить компоновку приложения в производство, необходим отдельный веб сервер. Для этого, в проекте можно использовать пакет <span class="dark-red">http-server</span>, поэтому загрузим его, перейдем в папку с результатами компоновки и запустим сервер: </p>
	<app-sample-code [context]="{header : 'Изменение представления в шаблоне компонента', headerBackground : '#d5dcff', ext : '.html'}">
<pre class="dark-blue">
   &#60;h1&#62;Version V1 is runnning ...&#60;/h1&#62;
</pre>
	</app-sample-code>
	<p>Затем выполним компоновку приложения, и поскольку, сервисный рабочий генерируется в компоновки приложения на продакшн, нужно выполнить сборку приложение с настройкой <span class="dark-red">--prod</span>. После компоновки, будет создана папка <span class="dark-red">dist</span>, и в неё помещен результат компоновки приложения. </p>
	<app-sample-code [context]="{header : 'Команда запуска чистовой компоновки приложения', headerBackground : '#d5dcff', ext : 'cmd'}">
<pre class="dark-blue">
   ng build --prod
</pre>
	</app-sample-code>
	<h3>Папка чистовой компоновки.</h3>
	<p>После чистовой компоновки в папку <span class="dark-red">dist</span> валятся файлы сгенерированные <span class="dark-blue">webpack</span> - основным компоновщиком Angular, которые имеют, примерно, вот такой вот вид: </p>
	<div class="dist-folder-img">
		<img alt="Изобрадение папок" src="/assets/imgs/angular-service-worker/ngsw-9.png">
	</div>
	<p>Как видно, настройка <span class="dark-blue">serviceWorker : true</span> в файле конфигурации приложения <span class="dark-blue">angular.json</span> ответственна за формирование двух файлов, находящихся в папке назначения, выделенных синим.</p>
	<h3>ngsw-worker.js</h3>
	<p>Этот файл содержит определение самого сервисного рабочего. Согласно спецификации, сервисный рабочий получается из отдельного HTTP запроса, поэтому браузер может отследить изменения этого файла, и применить к нему события жизненного цикла, установив обработчики собития. За загрузку этого файла отвечает модуль <span class="dark-blue">ServiceWorkerModule</span>, неявно вызывая метод <span class="dark-blue">navigation.serviceWorker.register()</span>. Этот файл всегда будет одинаковым после нескольких компоновок приложения (версионировании), поскольку он копируется из папки модулей <span class="dark-blue">node_modules</span>. Этот файл не измениться до тех пор, пока не обновиться новая версия модулей Angular, которая и будет содержать новую версию сервисного рабочего Angular. </p>
	<h3>ngsw.json</h3>
	<p>Файл конфигурации, необходимый файлу сервисного рабочего во время исполнения кода, строиться на основе файла <span class="dark-blue">ngsw-config.json</span> и содержит всю необходимую информацию о файлах приложения, которые необходимо кэшировать и их модели загрузки и кэширования. Из примера файла ниже, можно видеть, что он похож на расширенную версию файла <span class="dark-blue">ngsw-config.json</span>, где шаблонные адреса к файлам заменены на физические (реальные), соответствующие этим шаблонам.</p>
	<app-sample-code [context]="{header : 'Пример файла ngsw.json', headerBackground : '#d5dcff', ext : '.json'}">
<pre class="dark-blue">
   &#123;
	"configVersion": 1,
	"index": "/index.html",
	"assetGroups": [
    &#123;
      "name": "app",
      "installMode": "prefetch",
      "updateMode": "prefetch",
      "urls": [
        "/favicon.ico",
        "/index.html",
        "/inline.5646543f86fbfdc19b11.bundle.js",
        "/main.3bb4e08c826e33bb0fca.bundle.js",
        "/polyfills.55440df0c9305462dd41.bundle.js",
        "/styles.1862c2c45c11dc3dbcf3.bundle.css"
      ],
      "patterns": []
    &#125;,
    &#123;
      "name": "assets",
      "installMode": "lazy",
      "updateMode": "prefetch",
      "urls": [],
      "patterns": []
    &#125;
  ],
  "dataGroups": [],
  "hashTable": &#123;
    "/inline.5646543f86fbfdc19b11.bundle.js": "1028ce05cb8393bd53706064e3a8dc8f646c8039",
    "/main.3bb4e08c826e33bb0fca.bundle.js": "ae15cc3875440d0185b46b4b73bfa731961872e0",
    "/polyfills.55440df0c9305462dd41.bundle.js": "c3b13e2980f9515f4726fd2621440bd7068baa3b",
    "/styles.1862c2c45c11dc3dbcf3.bundle.css": "3318b88e1200c77a5ff691c03ca5d5682a19b196",
    "/favicon.ico": "84161b857f5c547e3699ddfbffc6d8d737542e01",
    "/index.html": "cfdca0ab1cec8379bbbf8ce4af2eaa295a3f3827"
  &#125;
&#125;
</pre>
	</app-sample-code>
	<h3>Как сервисный рабочий Angular использует файл ngsw.json?</h3>
	<p>Сервисный рабочий загружает файлы (клиенты) заранее, в случае, если режим установки этих файлов - <span class="dark-blue">prefetch</span> (предзагрузка), или при явном запросе этих ресурсов со страницы, в случае режим установки - <span class="dark-blue">lazy</span> (по требованию), что в любом случае сохранит эти файлы в кэш приложения <span class="dark-blue">Cache Storage</span>.<br> Эта загрузка происходит в фоне, не явно, при первом запуске приложения. При следующем запуске или обновлении страницы, сервисный рабочий перехватывает все сетевые запросы этих страниц или запросы с этих страниц, узнает уже произведенные запросы, и, согласно настроенным стратегиям кэширования ресурсов отдает эти ресурсы, либо их кэша, либо из сети, в зависимости от стратегии кэширования.<br> Следует обратить внимания на идентификаторы, присутствующие на концах имен файлов, которые соответствуют определенным записям в хешевых таблицах файла <span class="dark-blue">ngsw.json</span>. Если изменить какую либо запись из этой таблицы, даже на один символ, сервисный рабочий будет считать это изменением версии файла, и попытается его загрузить с сервера, согласно стратегии кэширования версионированных файлов, полагая, что на сервере появилось обновление.</p>
	<h2>Запуск приложения PWA в продакшн режиме.</h2>
	<p>Для локального запуска приложения в продакшн режиме нужен локальный веб сервер, который запустит файл приложения. Таким сервером может быть модуль <span class="dark-blue">http-server</span>, его нужно установить, после установки перейти в папку компоновки приложения и запустить сервер: </p>
	<app-sample-code [context]="{header : 'Запуск приложения через локальный сервер', headerBackground : '#d5dcff', ext : 'cmd'}">
<pre class="dark-blue">
   npm install -g http-server
   cd dist
   http-server -c-1
</pre>
	</app-sample-code>
	<p>Свойство <span class="dark-blue">-c-1</span> отключает кэширование сервера, который по умолчанию будет запускаться на порту 8080, отдавая файл приложения, из папки которой он запущен. Если порт 8080 занят, приложение может запуститься на портах 8081, 8082 и т.д., и используемый порт логируется в консоль при запуске. После запуска сервера нужно перейти по адресу запуска в браузере, в котром отобразиться надпись про версию приложения. В инструментах разработчика (закладка application) можно увидеть установленного сервисного рабочего.</p>
	<div class="start-service-worker-img">
		<img alt="Запуск приложения v1" src="/assets/imgs/angular-service-worker/ngsw-1.png">
	</div>
	<h3>Где храняться сборки Javascript и CSS?</h3>
	<p>Все сборки файлов приложения загружаються в фоне и устанавливаються в браузер в область <span class="dark-blue">Cash Storage</span>, содержимое которой можно увидеть на закладке <span class="dark-blue">Application</span> в инструментах разработчика. Сервисный рабочий загрузил все необходимые для приложения файлы, и пре перезапуске приложения, его загрузка и визуализация будет значительно быстрее первого запуска, потому, что практически все файлы будут взяты из кэша приложения, что скажется на увеличении его производительности.</p>
	<div class="start-service-worker-img">
		<img alt="Запуск приложения v1" src="/assets/imgs/angular-service-worker/ngsw-3.png">
	</div>
	<h3>Отключение приложения от сети.</h3>
<p>Для того, чтобы понять, что приложение может работать и вне сети, может запускаться и устанавливаться в браузер, нужно произвести несложный тест: остановить сервер, нажав <span class="dark-blue">Ctrl+C</span>. После остановки сервера можно обновить приложения в окне. Приложение будет продолжать работать в браузере, а в консоль выпадет сообщение о невозможность загрузить скрипт <span class="dark-blue">ngsw-worker.js</span>. Произойдет то, что все файлы, необходимые для работы приложения браузер возмет из кэша приложения, оттуда, куда их положил сервисный рабочий. Единственный файл, который будет запрошен с сервера и не получен, поскольку сервер остановлен, будет сам файл сервисного рабочего <span class="dark-blue">ngsw-worker.js</span>. Но так и должно произойти. </p>
	<app-sample-code [context]="{header : 'Сообщение о некритичной ошибки неудачного получения сервисного рабочего', headerBackground : '#d5dcff', ext : 'console'}">
<pre class="dark-blue" style="color: red;">
   An unknown error occurred when fetching the script.
   ngsw-worker.js Failed to load resource: net::ERR_CONNECTION_REFUSED
</pre>
	</app-sample-code>
	<h2>Развертывания новой версии приложения. Управление версионированием.</h2>
	<p>Не слишком ли опасно кэшировать всё, и что если в коде баг и необходимо заменить страрую версию кода на новую?<br>Скажем, мы произвели небольшие изменения в приложении, к примеру, изменили некоторые стили элемента в файле <span class="dark-blue">style.css</span>. Перед запуском чистовой компоновки, сохраним предыдущую версию файла <span class="dark-blue">ngsw.json</span>, для сравнения изменений. Теперь запустим сборку в производственную компоновку и при сравнении сгенерированного файла с сохраненным, увидим, что изменилась единственная запись для редактированного CSS файла, а остальные файлы не изменились, за исключением индексного файла <span class="dark-blue">index.html</span>, куда будет загружаться компоновка : </p>
	<div class="ngsw5-img">
		<img alt="Сравнение файлов сборки" src="/assets/imgs/angular-service-worker/ngsw-5.png">
	</div>
	<h3>Как сервисный рабочий Angular устанавливает новую версию приложения?</h3>
	<p>Каждый раз, когда пользователь перегружает страницу с приложением, сервисный рабочий проверяет появление новой версии файла <span class="dark-blue">ngsw.json</span> на сервере. Понимает он о том, что файл изменился, по его весу, т.е. количеству байт. Так происходит для согласования со  стандартом сервисного рабочего и во избежании работы устаревшей версии приложения в браузере пользователя. Устаревшие версии потенциально могут содержать баги или полностью быть неработоспособными, поэтому такая проверка проводиться часто.<br> В нашем случае предыдущая и новая версии файла <span class="dark-blue">ngsw.json</span> будут сравниваться и новая сборка CSS будет загружена и установлена в фоне. Следующий раз, когда пользователь перезагрузит страницу, ему отобразиться новая версия приложения.</p>
	<h3>Информирование пользователя о доступности новой версии.</h3>
	<p>Для долгоработающих одностраничных приложений, которые пользователь не закрывает часами, можно проводить периодическую проверку для определения таких обновлений и устанавливать их в фоне.<br>Для того чтобы запустить такую проверку, в коде следует использовать метод <span class="dark-blue">checkForUpdate()</span> сервиса <span class="dark-blue">SwUpdate</span>. Но в основном, необходимости в  вызове этого метода вручную нет, поскольку сервисный рабочий Angular производит автоматическую проверку новых версий при перезапуске приложений. Для долгоработающих приложений используется реактивное свойство для определения появления обновления и после этого можно запустить оповещение пользователю об этом, для того, что бы он смог перезапустить приложение для обновления версии.  </p>
	<app-sample-code [context]="{header : 'Оповещение пользователя при получении вызова о наличии обновления', headerBackground : '#d5dcff', ext : '.ts'}">
<pre class="dark-blue">
   @Component(&#123;
      selector: <span class="dark-green" >'app-root'</span>,
      templateUrl:<span class="dark-green" > './app.component.html'</span>,
      styleUrls: [<span class="dark-green" >'./app.component.css'</span>]
   &#125;)
   export class AppComponent  implements OnInit &#123;
      constructor(private swUpdate: SwUpdate) &#123;
   &#125;
   ngOnInit() &#123;
      if (this.swUpdate.isEnabled) &#123;
         this.swUpdate.available.subscribe(() => &#123;
            if(confirm(<span class="dark-green" >" Load New Version?"</span>)) &#123;
               window.location.reload();
            &#125;
         &#125;);
       &#125;
    &#125;
  &#125;
</pre>
	</app-sample-code>
	<p>Рассмотрим, что происходит в коде, когда на сервере оказывается новая версия приложения:</p>
	<ul>
		<li>Новые файлы доступны на сервере. Так же доступна и новая версия <span class="dark-blue">ngsw.json</span>, которая содержит информацию о том какие файлы загружать и когда. </li>
	</ul>
	<p>Но когда пользователь перезагружает приложение, он видит все ещё старую версию приложения. Это происходит потому, что в браузере работает старая версия сервисного рабочего, которая обслуживает старые версии файлов приложения из кэша приложения, обходя запросы на сервер. Когда сервисный рабочий выполнит запорос на проверку новой версии приложения, он загрузит все файлы, перечисленные в новой версии <span class="dark-blue">ngsw.json</span>. Как только все файлы будут загружены, сервисный рабочий передаст управление в обработчик подписки свойства <span class="dark-blue">available</span>, запустится диалог, который увидит пользователь, и он сделает выбор. Если он нажмет <span class="dark-blue">OK</span>, приложение полностью перезагрузиться и отобразиться новая его версия. Если не отобразить этого диалога пользователю, он будет видеть все ещё старую версию приложения, пока не перезагрузит приложение самостоятельно.</p>
	<div class="ngsw5-img">
		<img alt="Отображение диалога пользователю" src="/assets/imgs/angular-service-worker/ngsw-6.png">
	</div>
	<h3>Управление версионированием чрез сервисного рабочего Angular. Итоги.</h3>
	<p>Суммируя вышесказанное, можно представить его сжато:</p>
	<ul>
		<li>Новая версия приложения оказалась на сервере и новый файл <span class="dark-blue">ngsw.json</span> доступен. </li>
		<li>Первая перезагрузка приложения после появления новой версии приложения на сервере -  сервисный рабочий определяет новую версию файла сервисного рабочего и загружает его и файлы, которые он обслуживает (согласно стратегии кэширования этих файлов).</li>
		<li>Вторая перезагрузка приложения - пользователь видет работу этих новых файлов (новой версии приложения) на экране.</li>
		<li>Такое поведение является последовательным и не зависит от количества открытых вкладок (в отличии от стандартного поведения сервисного рабочего, когда для вступления в силу нового файла сервисного рабочего нужно закрывать все открытые вкладки).</li>
	</ul>
	<p>В этом месте статьи, мы имеем загружаемое и устанавливаемое приложение Angular PWA со встроенной системой версионирования. Далее, рассмотрим систему установки в один клик, используя иконку на рабочем столе мобильного устройства.</p>
	<h2>Однокликовая установка с помощью файла манифеста.</h2>
	<p>Необязательная функция - установка приложения в один клик, используя файл манифеста - означает, что файл сервисного рабочего может прекрасно работать и без этого файла, а он нужен лишь для того, что бы поддержать установку приложения на устройство. Диалог, отображающий обращение к пользователю с предложением установить его, появиться только при определенных условиях.</p>
	<h3>Файла манифеста</h3>
	<p>Для включение функциональности, нужно создать файл с именем <span class="dark-blue">manifest.json</span> и поместить его в корневую папку приложения, рядом с индексным файлом <span class="dark-blue">index.html</span>.</p>
	<app-sample-code [context]="{header : 'Пример файла манифеста', headerBackground : '#d5dcff', ext : '.json'}">
<pre class="dark-blue">
&#123;
   "dir": "ltr",
   "lang": "en",
   "name": "Angular PWA ",
   "scope": "/",
   "display": "fullscreen",
   "start_url": "http://localhost:8080/",
   "short_name": "Angular PWA",
   "theme_color": "transparent",
   "description": "Sample PWA App",
   "orientation": "any",
   "background_color": "transparent",
   "related_applications": [],
   "prefer_related_applications": false,
   "icons": [
    &#123;
      "src": "/favicon.ico",
      "sizes": "16x16 32x32"
    &#125;,
    &#123;
      "src": "/assets/android-icon-36x36.png",
      "sizes": "36x36",
      "type": "image/png",
      "density": "0.75"
    &#125;,
    &#123;
      "src": "/assets/android-icon-48x48.png",
      "sizes": "48x48",
      "type": "image.png",
      "density": "1.0"
    &#125;,
    &#123;
      "src": "/assets/android-icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "density": "1.5"
    &#125;,
    &#123;
      "src": "/assets/android-icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "density": "2.0"
    &#125;,
    &#123;
      "src": "/assets/android-icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "density": "3.0"
    &#125;,
    &#123;
      "src": "/assets/android-icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "density": "4.0"
    &#125;
  ]
&#125;
</pre>
	</app-sample-code>
	<p>Этот файл определяет, как будет отображаться иконка приложения на экране, её цвет фона, краткое имя, модель отображения приложения, цвет панели инструментов устройства при отображении приложения и пр.</p>
	<h3>Связь манифеста с индексным файлом приложения для его загрузки.</h3>
	<p>После того, как файл манифеста будет установлен, его нужно объявить для загрузки в индексном файле приложения, в области заголовка:</p>
	<app-sample-code [context]="{header : 'Объявление файла манифеста в приложении', headerBackground : '#d5dcff', ext : '.html'}">
<pre class="dark-blue">
  &#60;!doctype html&#62;
   &#60;html lang="en"&#62;
   &#60;head&#62;
     &#60;meta charset="utf-8"&#62;
     &#60;title&#62;NgPwa&#60;/title&#62;
     &#60;base href="/"&#62;
     &#60;meta name="viewport" content="width=device-width, initial-scale=1"&#62;
     &#60;link rel="icon" type="image/x-icon" href="favicon.ico"&#62;
     <span class="dark-red" >&#60;link rel="manifest" href="manifest.json"&#62;</span>

   &#60;/head&#62;
   &#60;body&#62;
     &#60;app-root&#62;&#60;/app-root&#62;
   &#60;/body&#62;
   &#60;/html&#62;
</pre>
	</app-sample-code>
	<h3>Настройка CLI для использования манифеста.</h3>
	<p>Для того, что бы файл манифеста попал в чистовую сборку, нужно сконфигурировать файл настройки CLI <span class="dark-blue">angular.json</span> , включив файл манифеста в область ресурсов, котрые без изменения будут помещены в папку <span class="dark-blue">assets</span> корня компоновки, после чего файл манифеста будет скопирован в папку ресурсов:</p>
	<app-sample-code [context]="{header : 'Отрывок настройки метаданных CLI ', headerBackground : '#d5dcff', ext : 'angular.json'}">
<pre class="dark-blue">
"apps": [
   &#123;
   "root": "src",
   "outDir": "dist",
   "assets": [
      "assets",
      "manifest.json",
      "favicon.ico"
   ], ...
</pre>
  </app-sample-code>
	<p>Если, после помещения файла манифеста перезагрузить приложение, то ничего не произойдет, поскольку для отображения диалога установки приложения на рабочий стол устройства, необходимо соблюдение некоторых условий.</p>
	<h3>Запуск установки на экран устройства.</h3>
	<p>Для отображения диалога установки приложения на экран пользователя должны сработать рад (совокупность) правил или <a target="_blank" href="https://developers.google.com/web/fundamentals/app-install-banners/">критерий</a> , называемые эвристикой. На сегодня, эти правила включают в себя:</p>
	<ul>
		<li>Веб приложение еще не установлено на устройство.</li>
		<li>Пользователь взаимодействовал с приложением (находился на странице приложения) не менее 30 секунд.</li>
		<li>В файл манифеста включены следующие свойства:
			<ul>
				<li>short_name или name</li>
				<li>Свойство icon должно иметь ссылки на иконки с разрешением 192px и 512px</li>
				<li>start_url</li>
				<li>Свойство display должно иметь одно из значений : fullscreen, standalone, или minimal-ui</li>
			</ul>
		</li>
		<li>Сервер приложения должен работать по протоколу HTTPS</li>
		<li>Приложение должно регистрировать сервисного рабочего и иметь в определении метод перехвата <span class="dark-blue">fetch</span>.</li>
	</ul>
	<p>Однако, можно запустить диалог добавления приложения на экран устройства и вручную, нажав на ссылку в инструментах разработчика <span class="dark-blue"> Add To Home Screen </span> </p>
	<div class="ngsw5-img">
		<img alt="Отображение диалога пользователю" src="/assets/imgs/angular-service-worker/ngsw-7.png">
	</div>
	<p>Ниже, представлен диалог, отображающийся на мобильном устройстве:</p>
	<div class="dist-folder-img">
		<img alt="Отображение диалога пользователю" src="/assets/imgs/angular-service-worker/ngsw-8.png">
	</div>
	<h3>Итоги</h3>
	<p>Установка и запуск веб приложения на устройстве, теперь проще, чем когда либо, используя сервисного рабочего Angular. Преимущества в производительности, которые получаются приложениями существенны и могут быть добавлены в приложение последовательно, согласно прогрессивной модели. Любое приложение получает преимущества от сокращения времени на загрузку и запуск, и такую функцию можно придать приложению по умолчанию, просто привыкнув настраивать Angular CLI определенным образом.</p>
</mat-card>